import telebot
import os
from dotenv import load_dotenv
from telegram import Bot
from telebot import types

load_dotenv()

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")

bot = telebot.TeleBot(TOKEN)


# Список кортежей с фиксированными вопросами и ответами
fixed_qa_list = [
    (1, "Что такое LA? В каких единицах измеряется?", "LA (load average) — параметр, определяющий среднюю нагрузку на систему за период времени (1 мин, 5 минут, 15 минут). Изменяется в количестве задач на одно ядро процессора. На нагрузку системы также влияет количество задач ввода-вывода и задержка сети. Также влияние на расчета LA оказывает: 1. Технология Hyper-Threading, которая делит одно физическое ядро на 2 логических, 2. Технология Turbo Bust, которая позволяет разгонять тактовую частоту процессора и работать на частоте выше заявленной, т.е. выше номинальной частоты (время на обработку одной задачи уменьшается)."),
    (2, "Что будет если на сервере LA = 100?", "Вероятно, что на сервере будет наблюдаться замедленная работа сервисов, но если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной."),
    (3, "Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?", "На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр wa в утилите top) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему."),
    (4, "Представлен вывод команды top. Что означает каждая запись в выводе?\n" "top - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10\n""Tasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie\n""%Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st\n""KiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache\n""KiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem\n", "top – название утилиты. 21:29:24 – текущее время системы. up 14:18 – сколько часов:минут система работает с момента последнего запуска. 1 user – количество пользователей авторизованных в системе. load average: 0,78, 1,48, 1,10 – параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут. 277 total – всего процессов в системе. 3 running – количество процессов в работе. 274 sleeping – количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала. 0 stopped – количество приостановленных процессов сигналом STOP или выполнением трассировки. 0 zombie – количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения. us (user)Использование процессора пользовательским процессами. sy (system)Использование процессора системным процессами. ni (nice)Использование процессора процессами с измененным приоритетом с помощью команды nice. id (idle)Простой процессора. Можно сказать, что это свободные ресурсы. wa (IO-wait)Говорит о простое, связанным с вводом/выводом. hi (hardware interrupts)Показывает сколько процессорного времени было потрачено на обслуживание аппаратного прерывания. si (software interrupts)Показывает сколько процессорного времени было потрачено на обслуживание софтверного прерывания. st (stolen by the hypervisor)Показывает сколько процессорного времени было «украдено» гипервизором. KiB Mem – количество оперативной памяти в кибибайтах (кратно 1024): 7106404 total — всего доступно оперативной памяти в системе, 306972 free — свободно оперативной памяти для использования, 3127144 used — использовано оперативной памяти, 3672288 buff/cache — буферизовано/закешировано оперативной памяти. KiB Swap – количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске: 8191996 total – всего выделено swap-памяти, 8191996 free – свободно swap-памяти 0 used – использовано swap-памяти, 3270520 avail Mem – доступно для использования swap-памяти."),
    (5, "Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?", "В утилите top нажать 1, чтобы отобразить все ядра в системе."),
    (6, "Как в утилите top в Linux посмотреть какой командой был запущен процесс?", "В утилите top нажать c, чтобы отобразить команды, которыми были запущены процессы."),
    (7, "Где хранятся имена файлов/директорий?", "Имена файлов и директорий хранятся в структуре данных, называемой ""индексным дескриптором"" (inode) Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса. Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса." ),
    (8, "Как удалить файл с именем -rf?", "rm ./-rf"),
    (9, "Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?", "Посмотреть полную информацию по дискриптору возможно командой stat <path_to_file>. Время модификации: stat --format=%y dira"),
    (10, "Для чего нужна переменная окружения PATH?", "PATH определяет список каталогов, в которых операционная система будет искать исполняемые файлы (выполняемые программы) без указания полного пути к ним. Когда вы вводите команду в терминале или командной строке, операционная система ищет исполняемый файл этой команды в каждом из каталогов, перечисленных в PATH, поочередно, слева направо."),
    (11, "Как посмотреть нагрузку на диски?", "Установить утилиту sysstat, проверить нагрузку на диски iostat -xtc"),
    (12, "Что такое файл в понятиях Unix-like операционных системах?", "В контексте Unix-like операционных систем, файл — это базовый элемент хранения данных, который используется для организации информации на диске. В Unix-подобных системах, включая Linux, файлы могут представлять различные типы данных, такие как текстовая информация, исполняемый код, архивы, директории и многое другое."),
    (13, "Что такое RAID? Какие массивы бывают?", "RAID (Redundant Array of Independent Disks) — это технология объединения нескольких физических дисков в единое хранилище данных с целью увеличения производительности, надежности и/или емкости. RAID создает виртуальный диск, который может включать в себя два или более физических диска. В зависимости от конфигурации RAID можно достичь различных целей, таких как повышение скорости чтения/записи, обеспечение отказоустойчивости или обеих этих характеристик. В зависимости от количества дисков и класса отказоустойчивости существуют следующие основные типы RAID: RAID 0: RAID 1: RAID 5: RAID 6: RAID 10:"),
    (14, "При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?", "RAID 6 обеспечивает работоспособность при выходе из строя до двух дисков одновременно. Это достигается благодаря наличию двух блоков паритетной информации на массив, что позволяет восстановить данные в случае отказа до двух дисков."),
    (15, "В чем разница между объявлением переменной export VAR=""VALUE"" и VAR=""VALUE"" в bash?", "При объявлении переменной через export – переменная будет доступна в любых других процессах, при обычном объявлении переменной – переменная будет доступна только в запущенном процессе."),
    (16, "Как остановить выполнение скрипта в bash при возникновении ошибки в команде?", "Как остановить выполнение скрипта в bash при возникновении ошибки в команде?"),
    (17, "Что в bash скрипте означает команда set -euo pipefail?", "Команда set устанавливает аттрибуты оболочки с опеределенных опций. Опция -e – означает, что скрипт будет остановлен, когда произойдет ошибка в ходе его выполнения. Опция -u – означает, что скрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена. Опция -o pipefail – означает, что скрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка."),
    (18, "Как активировать debug режим в bash?", "Команда set -x в начале скрипта активирует вывод в консоль debug информации."),
    (19, "Что значит $@ в bash?", "$@ – все параметры переданные скрипту."),
    (20, "Какой код сигнала будет выполнен при исполнении команды kill ?", "Сигнал SIGTERM (код 15) – это сигнал по-умолчанию отправляемый при вызове команды kill. Это указывает процессу на завершение работы и обычно считается сигналом для использования при чистом завершении работы."),
    (21, "Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?", "cmd 2>&1 >/dev/null | grep pattern"),
    (22, "Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?", "Команда w покажет список пользователей, которые вошли на сервер."),
    (23, "Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?", "Необходимо редактировать файл /etc/ssh/sshd_config, отвечающий за конфигурацию сервиса ssh."),
    (24, "В каком файле находится информация о смонтированных каталогах в файловую систему?", "Файл /etc/fstab содержит информацию о смонтированных каталогах в файловую систему."),
    (25, "Что выведет команда cat a и почему?\n mkdir /tmp/abc\n cd /tmp/abc\n ls >a 2>b\n cat a\n", "cat a выведет\n a\n b\n Обработка команды идёт справа налево. Сначала создается файл b, потом создается файл a, команда ls отображает список файлов в текущей директории (файлы a и b уже созданы) в одну колонну и перенаправляет стандартный поток вывода (>) в файл a, а стандартный поток ошибок 2 в файл b."),
    (26, "В bash-скрипте указан атрибут оболочки set -x. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?", "1 вариант: указать || true после выполнения команды с ошибкой.\n <command with error> || true\n 2 вариант: до выполнения данной команды указать set +e для игнорирования ошибок, начиная со следующей строки и после выполнения команды указать set -e для завершения работы скрипта в случае ошибки, начиная со следующей строки.\n set -e\n <command 1>\n <command 2>\n set +e\n <command 3 wih error>\n set -e\n"),
    (27, "Что такое системный вызов, какие они бывают?", "Системный вызов – обращение программы к ядру операционной системы для выполнения какой-либо операции.\nВ Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:\n open\n read\n write\n close\n wait\n exec\n fork\n exit\n kill\n"),
    (28, "Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?", "В Unix-подобных операционных системах сигналы - это механизм, который позволяет процессам общаться друг с другом и с ядром операционной системы. Сигналы используются для уведомления процессов о различных событиях, таких как завершение выполнения, запрос завершения, изменение размера терминала и другие..\nSIGTERM	15	Сигнал завершения (сигнал по умолчанию для утилиты kill)\nSIGKILL	9	Безусловное завершение "),
    (29, "Что такое inode? Какая информация там хранится?", "node (индексный дескриптор) – структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера inodes уникальны на уровне раздела. Каждый раздел как собственная таблица индексов. Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное место на данном разделе.\nInodes хранит метаданные о файле, к которому он относится. Эти метаданные содержат всю информацию об указанном файле.\n Размер\n Разрешение\n Владелец/группа\n Расположение жесткого диска\n Дата/время\n Любая другая необходимая информация\n"),
    (30, "Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.", "Жёсткая ссылка (Hard Link)\nЖёсткая ссылка — это дополнительное имя (путь) к файлу в файловой системе.\nСимволическая ссылка (Soft Link)\nСимволическая (софт) ссылка — это отдельный файл, который содержит путь к другому файлу в файловой системе.\n\nРазница с символической ссылкой\nЖёсткие ссылки указывают на индексы inode на диске, а не на пути к файлу.\nЕсли удалить все имена жёсткой ссылки, файл сохраняет свои данные на диске до тех пор, пока есть хотя бы одно имя, указывающее на него.\n\nРазница с жёсткой ссылкой\nСимволическая ссылка является отдельным файлом с собственным inode, который содержит путь к целевому файлу.\nЕсли удалить исходный файл, символическая ссылка будет битой (указывать на несуществующий файл).\n\nПрименение\nЖёсткие ссылки\nО беспечение доступа к одним и тем же данным из разных каталогов.\n Сохранение резервных копий файлов в одном месте.\n Использование в системных файловых структурах.\n\nСимволические ссылки\n Создание удобных псевдонимов для файлов.\n Использование в сценариях, где необходима гибкость в указании путей.\n Создание ссылок на динамические библиотеки и заголовки в программировании."),
    (31, "Какие состояния процессов существуют? Что значит состояние процесса D?", "R (running or runnable)\nВыполняется или готов к выполнению\nD (uninterruptible sleep)\nОжидает записи на диск\nS (interruptible sleep)\nНеактивен (< 20 s)\nT (stopped by job control signal)\nОстановлен или трассируется отладчиком\nZ (zombie)\nзомби\nW (paging (not valid since the 2.6.xx kernel))\nПроцесс выгружен на диск\n<\nПроцесс имеет повышенный приоритет nice\nN\nПроцесс имеет пониженный приоритет nice\nL (locked)\nНекоторые страницы блокированы в ядре\ns\nПроцесс является лидеров сеанса"),
    (32, "Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?","Процесс-зомби — это процесс, который завершил выполнение своей работы, но ещё остался в системе в виде записи в таблице процессов. Все ресурсы, связанные с процессом-зомби, освобождены, и сам процесс не занимает системные ресурсы. Он сохраняет запись для того, чтобы родительский процесс мог запросить статус завершения своего потомка.\nПроцесс-сирота — это процесс, который завершил выполнение, но его родительский процесс раньше завершился или отсоединился от него. Процессы-сироты могут быть усыновлены процессами-последователями, таким образом, они не остаются зомби, как процессы-зомби, и успешно завершают свою работу.\nСоздание зомби-процессов напрямую из пользовательского кода не является обыденной или полезной задачей. Зомби появляются естественным образом при завершении выполнения процессов в системе, и их обработка обычно лежит на родителе. Инструкции по созданию зомби-процессов не предоставляются, так как это не имеет практического смысла в реальных сценариях программирования."),
    (33, "Что такое файловый дескриптор? Какая информация там хранится?", "Файловый дескриптор – неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор."),
    (34, "Что такое buffer/cache память? Для чего нужна?", "Buffer память - это область оперативной памяти, используемая для временного хранения данных, которые скоро будут переданы на устройство ввода/вывода (I/O). Например, когда происходит чтение данных с жесткого диска, они сначала помещаются в буфер, а затем передаются в приложение. Это ускоряет доступ к данным, так как приложение может читать данные из буфера, а не ожидать завершения операции ввода/вывода.\nCache память - это также область оперативной памяти, но она используется для хранения копий данных из более медленной памяти (например, жесткого диска) с целью ускорения доступа к этим данным. Кэш содержит копии часто используемых данных, чтобы уменьшить задержки при их запросе.\nНазначение buffer/cache памяти:\nУлучшение производительности:\n  Buffer: Ускорение операций ввода/вывода, предварительно загружая данные из медленных устройств в буфер.\n  Cache: Ускорение доступа к часто используемым данным, уменьшая задержки при запросах.\nЭффективное использование ресурсов:\n  Buffer: Позволяет эффективно управлять потоками данных, избегая блокировок и ожиданий.\n  Cache: Сокращает время доступа к данным, улучшая общую производительность системы.\nМинимизация использования внешних устройств:\n  Buffer: Позволяет группировать и оптимизировать передачу данных между устройствами.\n  Cache: Позволяет часто используемым данным оставаться в быстрой оперативной памяти, минимизируя необходимость загрузки с медленных устройств."),
    (35, "Представлен вывод команды free.\ntotal used free shared buff/cache available\nMem: 6930 3598 843 183 2489 2919\nSwap: 15999 4 15995\nПочему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?","Total. Эта цифра представляет всю существующую память.\nUsed вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.\nused = total - free - buff/cache\nFree – свободная память в системе.\nShared – память, используемая (преимущественно) в tmpfs\nBuffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».\nAvailable – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки. В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент."),
    (36, "Порядок загрузки дистрибутива Linux.", "Включение компьютера кнопкой.\nЗагрузить BIOS / UEFI из NVRAM.\nСобрать сведения об аппаратуре.\nВыбрать устройства для запуска (диск, сеть).\nИдентифицировать системный раздел EFI.\nЗагрузить BIOS / UEFI из NVRAM.\nОпределить какое ядро загрузить.\nЗагрузить ядро.\nСоздать структуры данных ядра.\nЗапустить init / systemd как PID 1.\nВыполнить сценарии запуска.\nЗапустить систему."),
    (37, "Что такое GitFlow?" ,"GitFlow — это модель ветвления и соглашение об именовании веток для системы контроля версий Git."),
    (38, "Чем merge отличается от rebase?", "Merge и rebase - это два различных способа интеграции изменений из одной ветки в другую в системе контроля версий Git.\nMerge (слияние)\nОсновная идея: Создает новый коммит, который объединяет изменения из двух веток.\nRebase (перебазирование)\nОсновная идея: Перемещает текущую ветку в конец другой ветки и создает новые коммиты на основе изменений второй ветки."),
    (39, "Чем tag отличается от branch?", "Тег (Tag) и ветка (Branch) в системах контроля версий, таких как Git, представляют собой два различных механизма для маркировки определенных состояний репозитория, но они служат разным целям и имеют разные характеристики:\nВетка (Branch):\nНазначение: Ветка представляет собой линию разработки в репозитории. Она может быть использована для разработки новых функций, исправления ошибок и обновлений проекта.\nДинамичность: Ветка может изменяться, добавлять новые коммиты, интегрировать изменения из других веток и так далее.\nИспользование: Обычно используется для активной разработки кода.\nТег (Tag):\nНазначение: Тег представляет собой статическую метку для определенного коммита или состояния репозитория. Он используется для фиксации определенного момента в истории проекта, например, для обозначения выпуска версии.\nНестроимость: Тег является статичным и не изменяется после создания. Он связан с определенным коммитом и сохраняет это соответствие.\nИспользование: Обычно используется для обозначения релизов или других важных точек в истории проекта."),
    (40, "В ветке develop есть коммит с изменениями, которые нужно перенести в ветку master. Как это сделать?","Чтобы перенести изменения из ветки develop в ветку master, вы можете воспользоваться несколькими способами в Git. Один из распространенных способов — использовать команду git merge\nПереключитесь на ветку master:\ngit checkout master\nВыполните слияние изменений из ветки develop:\ngit merge develop"),
    (41, "Для чего нужна команда git commit --amend?", "Команда git commit --amend используется для внесения изменений в последний коммит. Это может быть полезно, если вы заметили небольшие ошибки в последнем коммите или хотите внести дополнительные изменения в тот же коммит, без создания нового."),
    (42, "Что такое Trunk-based development?","Trunk Based Development (TBD) - это подход, при котором вся разработка ведется на основе единственной ветки trunk (ствол). Чтобы воплотить такой подход в жизнь, нам нужно следовать трем основным правилам:\n1) Любые коммиты в trunk не должны ломать сборку.\n2) Любые коммиты в trunk должны быть маленькими на столько, чтобы review нового кода не занимало более 10 минут.\n3) Релиз выпускается только на основе trunk."),
    (43, "Состояние репозитория ушло на много коммитов вперед. Как откатить весь репозиторий к определенному коммиту?", "Чтобы откатить весь репозиторий к определенному коммиту, вы можете использовать команду git reset.\nОпределите хэш (или часть хэша) коммита, к которому вы хотите откатиться. Вы можете увидеть список коммитов с помощью команды git log. Найдите нужный вам коммит и скопируйте его хэш.\nОткатитесь к выбранному коммиту с помощью команды git reset --hard <хэш коммита>:\ngit reset --hard <хэш коммита>\nЗамените <хэш коммита> на фактический хэш коммита, к которому вы хотите откатиться.\nЕсли вам нужно обновить удаленный репозиторий, выполните команду git push --force:\ngit push --force"),
    (44, "В репозиторий запушен коммит с изменениями в двух файлах. Как откатить изменения этого коммита?", "Если вы хотите откатить последний коммит, включая изменения в файлах, вы можете использовать команду git reset\ngit reset --hard HEAD^\nЭта команда откатит HEAD (текущий коммит) на один предыдущий коммит и удалит все изменения, внесенные последним коммитом."),
    (45, "Что такое Docker? В чем отличие контейнера от образа?", "Docker - это платформа для разработки, доставки и запуска приложений в контейнерах. Контейнеры в Docker представляют изолированные среды выполнения, включая приложение, его зависимости и все необходимые файлы, обернутые в одну унифицированную упаковку. Docker позволяет разработчикам упаковывать приложения со всеми их зависимостями в контейнер, который может быть развернут на любой системе, поддерживающей Docker.\nОбраз (Image): Это статическая упаковка, содержащая все необходимые файлы, зависимости и конфигурации для запуска приложения. Образ является своего рода шаблоном.\nКонтейнер (Container): Это экземпляр образа во время выполнения. Контейнер представляет собой запущенный процесс, изолированный от окружающей системы и основанный на образе. Контейнеры динамичны и могут изменять свое состояние в процессе выполнения."),
    (46, "Какие инструкции есть у Dockerfile?","Dockerfile - это текстовый файл, в котором определяется процесс создания Docker-образа.\nПервой инструкцией всегда идёт FROM с указанием родительского образа. Например, FROM python:latest.\nИнструкция RUN может принимать конвейер команд Linux, чтобы не создавать лишние слои. Например, RUN apt-get update && apt-get install python3-pip -y && pip install --upgrade pip && pip install pipenv.\nИнструкция WORKDIR устанавливает рабочий каталог контейнера. Например, WORKDIR /usr/src/app/. Последующие команды RUN, CMD, ENTRYPOINT наследуют привязку WORKDIR.\nЗавершающей инструкцией всегда идёт CMD. Например, CMD [""python"", ""web_interface.py""]. CMD наследует привязку к WORKDIR, поэтому web_interface.py будет запущен из папки /usr/src/app/."),
    (47, "Чем отличается CMD от ENTRYPOINT в Dockerfile?","Форма использования:\nCMD используется для указания параметров, которые будут переданы команде по умолчанию, когда контейнер будет запущен.\nENTRYPOINT используется для установки основной команды, которая будет выполняться при запуске контейнера.\nПереопределение при запуске:\nПараметры CMD могут быть переопределены при запуске контейнера, передав новые аргументы через командную строку.\nПараметры ENTRYPOINT также могут быть переопределены, но они будут дополнены, а не полностью заменены. То есть, аргументы, переданные при запуске, добавятся к аргументам, указанным в ENTRYPOINT.\nФорма записи в Dockerfile:\nCMD может быть использован с несколькими формами записи: CMD [ executable, param1, param2 ] или CMD command param1 param2.\nENTRYPOINT также может быть использован с несколькими формами, но часто предпочтительна форма с массивом: ENTRYPOINT [ executable, param1, param2 ].\nПеременные окружения"),
    (48, "Чем отличается COPY от ADD в Dockerfile?", "ADD может извлекать файлы из внешних URL-адресов. Он также может извлекать сжатые файлы, если он поддерживает формат архива. Это также иногда создает проблему, если ADD не может поддерживать формат архива.\nCOPY был представлен как прямая замена ADD. COPY просто копирует файлы и каталоги. Вот и все. Для загрузки и извлечения файлов с инструкциями RUN используются обычные команды Linux, такие как curl и tar."),
    (49, "Какие есть best practices для написания Dockerfile?", "Запускать только один процесс на контейнер.\nСтараться объединять несколько команд RUN в одну для уменьшения количества слоёв образа.\nЧастоизменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.\nУказывать явные версии образов в инструкции FROM, чтобы избежать случая, когда выйдет новая версия образа с тегом latest.\nПри установке пакетов указывать версии пакетов.\nОчищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.\nИспользовать multistage build для сборки артифакта в одном контейнере и размещении его в другом."),
    (50, "Какие типы сетевых драйверов используются в docker?\nЧто такое эфемерные контейнеры?", "bridge - это встроенный драйвер сети, который создает виртуальный Ethernet-мост на хосте. Контейнеры, использующие этот драйвер, могут взаимодействовать друг с другом и с хостом.\nhost - контейнеры, использующие этот драйвер, используют сетевое пространство хоста, а не свое собственное. Это означает, что они имеют те же сетевые интерфейсы и порты, что и хост.\noverlay - этот драйвер предназначен для создания многомашинных кластеров Docker, позволяя контейнерам в разных узлах связываться друг с другом.\nmacvlan - позволяет назначать контейнерам реальные MAC-адреса, делая их видимыми в локальной сети, как если бы это были физические устройства.\nnone - контейнеры, использующие этот драйвер, не имеют сетевого интерфейса. Это может быть полезно в случае, когда контейнерам не требуется сетевого взаимодействия.\nПользовательские мосты могут быть созданы для определенных сценариев. Это позволяет настраивать параметры моста, такие как подсеть и IP-адрес.\nЭфемерные контейнеры (ephemeral containers) в контексте Kubernetes представляют собой временные контейнеры, которые могут быть запущены внутри существующего Pod (группы контейнеров) для отладки, ремонта или выполнения дополнительных задач."),
]
# Cписок вопросов
questions_text = (
"1)Что такое LA? В каких единицах измеряется?\n"
"2)Что будет если на сервере LA = 100?\n"
"3)Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?\n"
"4)Представлен вывод команды top. Что означает каждая запись в выводе?\n"
"top - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10\n"
"Tasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie\n"
"%Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st\n"
"KiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache\n"
"KiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem\n"
"5)Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?\n"
"6)Как в утилите top в Linux посмотреть какой командой был запущен процесс?\n"
"7)Где хранятся имена файлов/директорий?\n"
"8)Как удалить файл с именем -rf?\n"
"9)Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?\n"
"10)Для чего нужна переменная окружения PATH?\n"
"11)Как посмотреть нагрузку на диски?\n"
"12)Что такое файл в понятиях Unix-like операционных системах?\n"
"13)Что такое RAID? Какие массивы бывают?\n"
"14)При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?\n"
"15)В чем разница между объявлением переменной export VAR=""VALUE"" и VAR=""VALUE"" в bash?\n"
"16)Как остановить выполнение скрипта в bash при возникновении ошибки в команде?\n"
"17)Что в bash скрипте означает команда set -euo pipefail?\n"
"18)Как активировать debug режим в bash?\n"
"19)Что значит $@ в bash?\n"
"20)Какой код сигнала будет выполнен при исполнении команды kill ?\n"
"21)Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?\n"
"22)Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?\n"
"23)Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?\n"
"24)В каком файле находится информация о смонтированных каталогах в файловую систему?\n"
"25)Что выведет команда cat a и почему?\n"
"mkdir /tmp/abc\n"
"cd /tmp/abc\n"
"ls >a 2>b\n"
"cat a\n"
"26)В bash-скрипте указан атрибут оболочки set -x. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?\n"
"27)Что такое системный вызов, какие они бывают?\n"
"28)Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?\n"
"29)Что такое inode? Какая информация там хранится?\n"
"30)Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.\n"
"31)Какие состояния процессов существуют? Что значит состояние процесса D?\n"
"32)Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?\n"
"33)Что такое файловый дескриптор? Какая информация там хранится?\n"
"34)Что такое buffer/cache память? Для чего нужна?\n"
"35)Представлен вывод команды free.\n"
"$ free -m\n"
"total used free shared buff/cache available\n"
"Mem: 6930 3598 843 183 2489 2919\n"
"Swap: 15999 4 15995\n"
"Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?\n"
"36)Порядок загрузки дистрибутива Linux.\n"
"37)Что такое GitFlow?\n"
"38)Чем merge отличается от rebase?\n"
"39)Чем tag отличается от branch?\n"
"40)В ветке develop есть коммит с изменениями, которые нужно перенести в ветку master. Как это сделать?\n"
"41)Для чего нужна команда git commit --amend?\n"
"42)Что такое Trunk-based development?\n"
"43)Состояние репозитория ушло на много коммитов вперед. Как откатить весь репозиторий к определенному коммиту?\n"
"44)В репозиторий запушен коммит с изменениями в двух файлах. Как откатить изменения этого коммита?\n"
"45)Что такое Docker? В чем отличие контейнера от образа?\n"
"46)Какие инструкции есть у Dockerfile?\n"
"47)Чем отличается CMD от ENTRYPOINT в Dockerfile?\n"
"48)Чем отличается COPY от ADD в Dockerfile?\n"
"49)Какие есть best practices для написания Dockerfile?\n"
"50)Какие типы сетевых драйверов используются в docker?\nЧто такое эфемерные контейнеры?"
)



@bot.message_handler(func=lambda message: True)
def handle_all_messages(message):
    try:
        question_number = int(message.text)
        question, response = handle_fixed_questions(question_number)
        message_text = get_message_text(question, response)
        bot.send_message(message.chat.id, message_text, parse_mode='Markdown')
    except ValueError:
        bot.send_message(message.chat.id, questions_text)
        bot.send_message(message.chat.id, "Пожалуйста, введите номер вопроса, на который хотите получить ответ.")

def handle_fixed_questions(question_number: int) -> tuple:
    for item in fixed_qa_list:
        if item[0] == question_number:
            return item[1], item[2]
    return "Вопрос не найден", "Извините, не могу найти ответ на ваш вопрос."





def get_message_text(question, response) -> str:
    return f"{question}\n\n{response}"

if __name__ == "__main__":
    bot.polling(none_stop=True)